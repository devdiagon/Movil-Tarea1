\subsection{Widgets en Flutter}
El componente principal de toda aplicación de Flutter, son los Widgets. Estas piezas de código funcionan como bloques de construcción para crear interfaces de usuario (UI). Los widgets se organizan en base a una jerarquía, donde cada widget se anida dentro de otro widget, es de esta manera se genera una especie de “árbol de widgets”, donde cada widget puede obtener un contexto de su padre. \parencite{FlutterDocs2025}

Comúnmente se suele relacionar a los widgets con componentes estructurales definidos, como textos, botones, labels o demás. Lo cierto, es que los widgets son una estructura más compleja, con la cual es capaz de mostrar contenido, establecer temas, ajustar layouts, pero sobre todo, manejar interacciones con el usuario. \parencite{Gill2025}

Al momento de crear un widget, se tiene que generar una clase que herede las características del componente “statelessWidget” o “statefulWidget”. En cualquiera de los casos se \textbf{hereda atributo “key”:} Es un identificador único que ayuda a actualizar secciones específicas de la UI.

\subsection{Stateless widgets}
Es el tipo de widget más simple, pues se lo utiliza cuando el estado del mismo no debe ser mutable, es decir, sus atributos no cambian durante la compilación, por lo que se tendrá el mismo elemento durante toda la aplicación desde que se crea el widget.

Así, este tipo de widget solo implementa el método “build()” que contiene la estructura del widget, por lo que lo convierte en una solución bastante simple, fácil de predecir y optimizada en rendimiento. \parencite{Tllez2024}


\subsection{Stateful widgets}
Este tipo de widget que es capaz de cambiar luego de haber tenido alguna interacción por parte del usuario u otros medios. Para lograr alcanzar esto, se implementa el método “createState()” que sirve para crear un estado del widget declarado. Este estado se lo alacena en una clase separada que hereda la clase “State”. \parencite{Nwogu2023}

Cuando se almacena el estado del widget, se tiene un ciclo de vida, además del “createState()” con el cual se inicializa el widget por primera vez, se compone de los métodos:

\begin{itemize}
  \item \textbf{initState():} Se llama antes de que sea agregado al árbol de widgets, ocurre la inicialización del widget.
  \item \textbf{build():} Contiene la estructura del widget, considerando que será llamado cada vez que se tenga que volver a construir el widget cuando se cambia de estado.
  \item \textbf{setState():} Actualiza el estado del widget, lo que puede involucrar otras variables internas declaradas dentro del estado, es donde se implementa la lógica que posteriormente se verá reflejada en la UI.
  \item \textbf{dispose():} Este método se llama cuando el widget es eliminado del árbol de widgets, elimina cualquiera de los recursos usados por el widget.
\end{itemize}

\subsection{Tipos de widgets}
Existen varios widgets con diferentes propiedades cada uno. Algunos ofrecen mayores capacidades de personalización, por lo que en conjunto pueden lograr armar una UI coherente. \parencite{Pandya2025}

\textbf{Layout:} Define como los widgets se organizan en la pantalla. (\lstinline{Row}, \lstinline{Column}, \lstinline{Stack}, \lstinline{Expanded}, \lstinline{Container})

\textbf{Estructurales:} Proporciona una estructura básica (genérica) para la presentación de la aplicación. (\lstinline{Scaffold}, \lstinline{AppBar}, \lstinline{Drawer})


\textbf{Interactivos:} Permiten a las personas interactuar con la aplicación. (\lstinline{ElevatedButton}, \lstinline{TextButton}, \lstinline{IconButton}, \lstinline{TextField}, \lstinline{Checkbox}, \lstinline{Switch}, \lstinline{Radio})


\textbf{Widgets espeíficos de plataforma:} Se encuentran los ``Material widgets'' para Android y los ``Cupertino widgets'' para iOS, con la finalidad de tener experiencias más parecidas a como si hubiesen sido hechas nativamente.


\textbf{Estilos:} Ayudan a controlar la apariencia del diseño. (\lstinline{Padding}, \lstinline{Align}, \lstinline{Them}, \lstinline{DecoratedBox})

\subsection{Patrón MVC}

El patrón de arquitectura Modelo-Vista-Controlador, mejor conocido como MVC, es uno de los más utilizados dentro del desarrollo de software, debido a su gran simplicidad que permite organizar un proyecto de tal manera en la que pueda ser escalable y mantenible \parencite{Alvarez2023}. Este patrón se compone de 3 capas:

\textbf{Modelo:} Se encarga de trabajar directamente con los datos que se consumen en una aplicación. Generalmente se accede a una base datos, consumiendo sus recursos y realizando operaciones CRUD. De esta manera proporciona interfaces de programación para acceder a los recursos y poder manipularlos desde otras partes del código.

\textbf{Vista:} Muestra el código referente a la interfaz de usuario y todo lo referente a la usabilidad y experiencia de usuario. Es la parte de la personalización de la aplicación, siendo la encargada de actualizar estados y mostrar datos de manera atractiva en la pantalla. En otros casos también se encarga de manejar las rutas y la navegación entre pantallas, estableciendo optimizaciones necesarias para el mejorar el rendimiento.

\textbf{Controlador:} Su principal funcionalidad es la de servir como un enlace entre la vista y el modelo. Lo más común es que la vista llame al controlador y este controlador llame a alguna operación del modelo para obtener datos. Además, el controlador es el encargado de contener la lógica de negocio, por lo que puede realizar ciertas manipulaciones a los datos traídos por el modelo para llegar a hacer alguna acción en concreto.

\subsection{Atomic Design}
Es una metodología de diseño que parte de la idea simple de como se organizan los seres vivos. Su filosofía se basa en ir creando componentes reutilizables y personalizables para agilizar el desarrollo y favorecer la reutilización de componentes \parencite{Garca2024}. Todo esto siguiendo una estructura de diseño anteriormente preestablecida, como paletas de color, tamaño de texto, fuente y demás decisiones de diseño para aumentar la experiencia de usuario.

Sus fundamentos se basan en las siguientes estructuras:

\textbf{Átomos:} Son unidades básicas de diseño, tratándose de elementos sencillos como iconos, botones, inputs o etiquetas. Se llega a obtener un átomo cuando ser reconoce que no se lo puede descomponen en partes más pequeñas que esta.

\textbf{Moléculas:} Se obtienen al combinar distintos átomos, aunque siguen siendo de nivel elemental, puesto que puede ser reutilizable en varias partes de la aplicación. Un ejemplo podría ser composiciones definidas para una barra de búsqueda.

\textbf{Organismos:} Son componentes más grandes y complejos, puesto que incorporan varias moléculas, generalmente ya se tratan de piezas reconocibles dentro de la interfaz. Ejemplos pueden ser una barra de navegación o una tarjeta de un producto.

\textbf{Plantillas:} En este punto ya se define la estructura de una página o vista. Se encarga de organizar varios elementos a la vez para definir la disposición de los elementos en la pantalla.

\textbf{Páginas:} Esta es el nivel final, donde toma como base una plantilla y luego se la llena con contenido real para así presentarla al usuario.
